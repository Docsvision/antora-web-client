= Разработка расширения для программы DVWebTool

include::admin:partial$excerpts.adoc[tags=dvweb-win]

Дополнительным компонентом модуля {wc} является программа _DVWebTool_, которая предоставляет функциям {wc}а доступ к устройствам и программному обеспечению, установленному на компьютере пользователя {wc}а. Программа _DVWebTool_ также может быть использована для обработки произвольных задач на пользовательском компьютере.

Программа _DVWebTool_ является приложением для рабочего стола с возможностью расширения функциональности. Расширение _DVWebTool_ представляет собой DLL-файл, содержащий ожидаемый класс с веб-методами. Данные методы могут вызываться клиентскими компонентами {wc}а (есть стандартный метод JSAPI для вызова) или другими способами.

В качестве примера будет разработано расширение, реализующее функцию добавления водяных знаков в PDF-файлы карточки _Документ_. Пример расширения _DVSupService_ см. в разделе "xref:other/dv-sup-extensions.adoc[]".

.Алгоритм работы расширения:
. При вызове функции расширения Клиент передаёт идентификаторы PDF файлов карточки _Документ_ (идентификаторы карточек _Файл_ с версиями, а не идентификаторы собственно файлов) и идентификатор самой карточки _Документ_.
. Расширение _DVWebTool_ загружает PDF-файлы на компьютер пользователя с помощью функций, предоставляемых {wc}ом.
. Расширение _DVWebTool_ добавляет в полученные PDF-файлы водяные знаки, используя функции сторонней библиотеки для работы с PDF.
. Расширение _DVWebTool_ прикрепляет полученные файлы с водяными знаками с помощью функций, предоставляемых {wc}ом.
+
Расширение не должно изменять существующие файлы карточки: полученные PDF-файлы с водяными знаками должны быть добавлены в карточку в качестве дополнительных.

Для реализации функций, указанных в пп. 2 и 4, потребуется разработать расширение {wc}а с соответствующей функциональностью.

Также для примера необходимо разработать клиентское расширение, которое будет вызывать функции расширения _DVWebTool_ с передачей им идентификаторов PDF-файлов _Документа_, в которые нужно добавить водяные знаки.

== Расширение {wc}а

Полный код примера доступен в https://github.com/Docsvision/WebClient-Samples/tree/master/Others/Watermark[репозитории {dv} на GitHub].

Для работы расширения _DVWebTool_ необходимо, чтобы {wc} по запросу возвращал файл из карточки _Файл_ с версиями с переданным идентификатором, а также мог прикреплять переданные файлы к карточке _Документ_.

Требуемая функциональность может быть реализована с помощью расширения {wc}а.

Ниже приведена часть исходного кода контроллера, реализованного в серверном расширении.

.Файл `_Others\Watermark\WatermarkServerExtension\Controllers\FileOperationsController.cs_`
[source,csharp]
----
        public HttpResponseMessage GetFile(Guid fileCardID)
        {
            FileReader fileReader = fileService.GetFileReader(fileCardID);

            if (fileReader.FileId == Guid.Empty)
                return new HttpResponseMessage(HttpStatusCode.NotFound);

            HttpResponseMessage response = CreateResponseForFile(fileReader); <.>
            return response;
        }

        [HttpPost]
        public async Task<ActionResult> AddFile([FromForm(Name = "file")] FormFileCollection formFiles, Guid cardId) <.>
        {

            string rootPath = CreateAndGetTempFolder();
            try
            {
                List<string> files = await fileService.SaveFilesFromResponse(formFiles); <.>

                await fileService.AddFilesToCard(cardId, files);
                return Ok();

            }
            catch (Exception e)
            {
                return Problem(statusCode: (int)HttpStatusCode.InternalServerError, detail: e.Message);
            }
        }
----
<.> Создаёт ответ с файлом.
<.> Добавляет в карточку файлы из запроса.
<.> Добавляемые файлы.

В контроллере используется сервис `IFileService`, реализация которого приведена ниже. Код дополнительных методов смотрите в полном примере на GitHub.

// tag::fileservice[]
.Файл `_Others\Watermark\WatermarkServerExtension\Services\FileService.cs_`
[source,csharp]
----
    public class FileService : IFileService
    {
        private readonly ICurrentObjectContextProvider currentObjectContextProvider;
        private Guid DOCUMENT_CARD_ID = new Guid("B9F7BFD7-7429-455E-A3F1-94FFB569C794");

        public FileService(ICurrentObjectContextProvider currentObjectContextProvider) {
            this.currentObjectContextProvider = currentObjectContextProvider;
        }

        public async Task<IEnumerable<Guid>> AddFilesToCard(ObjectContext objectContext, Guid cardId, List<string> files) <.>
        {
            return await AddFiles(objectContext, cardId, files);
        }

        public async Task<IEnumerable<Guid>> AddFilesToCard(Guid cardId, List<string> files) <.>
        {
            ObjectContext objectContext = GetObjectContext();
            return await AddFiles(objectContext, cardId, files);
        }

        public FileReader GetFileReader(Guid fileCardId) <.>
        {
            ObjectContext objectContext = GetObjectContext();
            IVersionedFileCardService versionedFileCardService = GetVersionedFileCardService(objectContext);

            VersionedFileCard fileCard = versionedFileCardService.OpenCard(fileCardId); <.>

            Guid fileId = fileCard.CurrentVersion.Id; <.>

            UserSession userSession = GetUserSession();

            if (userSession.FileManager.FileExists(fileId) == false) <.>
                return new FileReader();

            var file = userSession.FileManager.GetFile(fileId); <.>

            return new FileReader() { <.>
                FileId = fileId,
                FileName = file.Name,
                Stream = file.OpenReadStream()
            };
        }
<.>
----
<.> Добавляет файлы из файловой системы в карточку `cardId` -- `AddFilesToCard(ObjectContext, Guid, List<string>)`.
<.> Добавляет файлы из файловой системы в карточку `cardId` -- `AddFilesToCard(Guid, List<string>)`.
<.> Получает указатель для чтения файла из карточки файла с версиями `fileCardID`.
<.> Получает файл карточки с версиями.
<.> Получает идентификатор файла из последней версии.
<.> Если файла нет, возвращает пустой указатель.
<.> Запрашивает файл текущей версии.
<.> Возвращает указатель для чтения файла.
<.> Код вспомогательных функций приведён в полном примере.
// end::fileservice[]

== Расширение программы DVWebTool

Когда реализовано расширение {wc}а, предоставляющее и записывающее файлы карточек, может быть реализовано расширение _DVWebTool_, использующее данные функции.

Расширение _DVWebTool_ представляет собой сборку, в которой реализован интерфейс `{dv}.DVWebTool.WebServices.IServiceManager`. Данный интерфейс определяет метод `Register`, который регистрирует контроллеры с необходимыми функциями во внутреннем веб-сервере _DVWebTool_, и поле `DisplayName` с названием расширения.

Ниже приведён код класса, реализующего интерфейс `IServiceManager` в данном примере.

.Файл `_Others\Watermark\DVWebToolExtension.WatermarkWebToolExtension\WatermarkManager.cs_`
[source,csharp]
----
    public class WatermarkManager : IServiceManager
    {
        public string DisplayName => "Watermark to PDF"; <.>

        public void Register(WebSocketSharper.Server.WebSocketServer server) <.>
        {
            server.AddWebSocketService<WatermarkController>("/Watermark"); <.>
        }
    }
----
<.> Название расширения для информации в окне "О программе".
<.> Регистрация контроллера расширения.
<.> Регистрация контроллера `WatermarkController` для маршрута `Watermark`.

В данном примере выполняется регистрация контроллера `WatermarkController` для обработки запросов, поступающих по пути `/Watermark`.

Контроллер, передаваемый в `AddWebSocketService`, должен быть производным типа `{dv}.DVWebTool.WebServices.BaseService`. При его реализации необходимо зарегистрировать в `BaseService.actions` веб-методы, с помощью которых будут вызываться функции _DVWebTool_, предоставляемые расширением. Данные методы будут доступны для вызова по протоколу `WebSocket` по адресу `ws://localhost:PORT/%Адрес контроллера%/%Название метода%`.

Ниже приведена часть реализации контроллера `WatermarkController`, содержащего методы обработки входящих запросов на добавление водяного знака. 

.Файл `_Others\Watermark\DVWebToolExtension.WatermarkWebToolExtension\WatermarkController.cs_`
[source,csharp]
----
    public class WatermarkController : BaseService
    {
        private readonly ServiceProvider serviceProvider;
        private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

        private string WATERMARK = "Секретно"; <.>

        public WatermarkController()
        {
            serviceProvider = new ServiceProvider();
            Init();
        }

        private void Init()
        {
            actions.Add(nameof(AddWatermarkToFiles), AddWatermarkToFiles);
        }

        private WebServiceResponse AddWatermarkToFiles(WebServiceRequest webServiceRequest, JObject data)
        {
            Logger.Info("Получено задание на добавление водяного знака");

            if (data == null)
            {
                return CreateBadResponse("С клиента не переданы данные для работы");
            }

            AddWatermarkRequest request; <.>
            try
            {
                request = data.ToObject<AddWatermarkRequest>();
            }
            catch
            {
                Logger.Error($"Ошибка преобразования полученного сообщения: {data}");
                return CreateBadResponse("Поступивший запрос не соответствует ожидаемому формату");
            }

            string doneInfo;

            try
            {
                doneInfo = HandleRequest(request).Result;
            }
            catch (Exception ex)
            {
                return CreateBadResponse(ex.Message);
            }

            return CreateEndProcessResponse(request.CardId, $"Водяные знаки добавлены в файлы:<p/>{doneInfo}");
        }

        private async Task<string> HandleRequest(AddWatermarkRequest request) <.>
        {
            var connectionService = new ConnectionToWebClient(request.ServerAddress);

            try
            {
                await connectionService.Authentificate();
            }
            catch (Exception ex)
            {
                Logger.Error(ex.Message);
                throw new Exception("Не удалось подключиться к серверу Web-клиента");
            }

            List<string> files = new List<string>();

            foreach (var fileId in request.FileIds) <.>
            {
                try
                {
                    string pathToFile = await connectionService.PullFile(fileId);
                    files.Add(pathToFile);
                }
                catch (Exception ex)
                {
                    Logger.Error(ex.Message);
                    throw new Exception($"Не удалось получить из карточки файл с идентификатором {fileId}");
                }
            }

            var watermarkService = new WatermarkService(); <.>

            List<Task<string>> processes = new List<Task<string>>(); <.>
            string doneInfo = "";

            foreach (var file in files)
            {
                try
                {
                    processes.Add(watermarkService.AddWatermark(file, WATERMARK));
                    doneInfo += $" {Path.GetFileName(file)}<p/>";
                }
                catch (Exception ex)
                {
                    Logger.Error(ex.Message);
                    throw new Exception($"Не удалось добавить водяной знак в файл {Path.GetFileName(file)}");
                }
            }

            var filesWithWatermark = await Task.WhenAll(processes);

            try
            {
                await connectionService.PushFiles(request.CardId, filesWithWatermark); <.>
            }
            catch (Exception ex)
            {
                Logger.Error(ex.Message);
                throw new Exception($"Не удалось сохранить файлы в карточке");
            }
            return doneInfo;
        }
<.>
----
<.> Текст водяного знака.
<.> Загружаем данные из полученного запроса в модель `AddWatermarkRequest`.
<.> Обработчик запроса на добавление водяного знака. Получает данные запроса. Возвращает строку с названиями файлов, в которые добавлены запросы.
<.> Загружаем с {wc}а файлы, идентификаторы которых переданы в запросе.
<.> Сервис для работы с водяными знаками.
<.> Добавление водяных знаков в файлы из списка `files`.
<.> Отправка запроса на прикрепление файлов `filesWithWatermark` к карточке `request.CardID`.
<.> С полным кодом примера можно ознакомиться в репозитории.

.Контроллер `WatermarkController` использует функции двух сервисов:
* `ConnectionToWebClient` для получения файлов из карточек Файл с версиями и загрузки файлов в карточки Документ. Данный сервис использует функции реализованного серверного расширения {wc}а.
* `WatermarkService` для добавления водяных знаков в PDF файлы.

NOTE: Реализации данных сервисов смотрите в исходных кодах примера на GitHub.

После публикации расширения _DVWebTool_ зарегистрированный в расширении метод `AddWatermarkToFiles` контроллера `Watermark` может быть вызван из клиентского расширения {wc}а с помощью сервиса `DVWebToolConnection`.

== Клиентское расширение

В качестве примера использования функций расширения _Watermark to PDF_ программы _DVWebTool_ было разработано клиентское расширение, которое выполняет две задачи:

* Получает из текущей открытой карточки Документа идентификаторы основных файлов формата PDF.
* Отправляет идентификаторы файлов расширению _Watermark to PDF_.

Общие требования к реализации клиентских расширений приведены в пункте "xref:client/client-extensions.adoc[Расширение возможностей клиентской части {wc}а]".

Прежде всего необходимо реализовать сервис, получающий список идентификаторов файлов, в которые в будущем будет добавлен водяной знак. Список идентификаторов нужно передавать в метод `AddWatermarkToFiles` расширения _Watermark to PDF_. Ниже приведён исходный код данного сервиса.

.Файл `_Others\Watermark\WatermarkWebExtension\src\WatermarkService.tsx_`
[source,typescript]
----
export class WatermarkService { <.>

    constructor(private services: $RequestManager & $WebServices & $ApplicationSettings & $MessageBox & $SiteUrl & $CurrentEmployeeId) {
    }

    AddWatermarkToFiles(cardID: string, fileIDs: string[]): Promise<IWebServicesResponse<any>> { <.>
        const data: any = { <.>
            data: {
                cardID: cardID,
                fileIDs: fileIDs,
                userID: this.services.currentEmployeeId,
                serverAddress: this.services.siteUrl
            },
            action: 'AddWatermarkToFiles', <.>
            locale: this.services.applicationSettings.culture.twoLetterISOLanguageName <.>
        };

        return DVWebToolConnection.trySendData("Watermark", data, this.services); <.>
    }
}

export type $WatermarkService = { watermarkService: WatermarkService }; <.>
export const $WatermarkService = serviceName((s: $WatermarkService) => s.watermarkService);
----
<.> Клиентский сервис, обеспечивающий доступ к методу добавления водяных знаков, предоставляемому расширением _DVWebTool_.
<.> Метод принимает идентификатор карточки и идентификатор её конвертируемых файлов.
<.> В данных нужно также передать:
+
* Адрес сервера {wc}а (_DVWebTool_ должен подключиться к {wc}у для получения и сохранения файлов карточки).
* Идентификатор пользователя (для отправки оповещения о завершении процесса).
+
<.> Название метода, вызываемого из расширения DVWebTool
<.> Обязательное для передачи название локали
<.> Вызываем метод `AddWatermarkToFiles` из контроллера Watermark расширения DVWebTool. Тип `DVWebToolConnection` предоставляет методы для работы с DVWebTool.
<.> Регистрируем сервис `WatermarkService`.

Сервис `$WatermarkService` предоставляет единственный метод `AddWatermarkToFiles`, который вызывает функцию программы _DVWebTool_ с помощью метода `DVWebToolConnection.trySendData`. При вызове данного метода нужно передать название контроллера и данные, в которых должно быть название вызываемого метода контроллера -- в поле `action` передаваемых данных.

В качестве метода, использующего сервис `$WatermarkService` реализуем обработчик нажатия кнопки разметки карточки Документ, который будет получать идентификаторы основных PDF-файлов карточки, вызывать метод `$WatermarkService.AddWatermarkToFiles` и после завершения его работы обновлять содержимое элемента управления Список файлов, или отображать ошибку.

// tag::eventhandler[]
.Файл `_Others\Watermark\WatermarkWebExtension\src\EventHandlers.tsx_`
[source,typescript]
----
export async function addWatermark(sender: LayoutControl) {
   showNotify("Запущен процесс добавления водяных знаков"); <.>

   let cardId = sender.layout.getService($CardId); <.>
   let files = sender.layout.getService($FileService).getFiles();

   let fileIDs = new Array();
   let tokenRequestModels: TokenRequestModel[] = []; <.>

   let watermarkService = sender.layout.getService($WatermarkService); <.>

   files.forEach((item) => {
      if (item.data.isMain && item.data.name.toLowerCase().endsWith(".pdf")) { <.>
         if (isLinuxOS()) {
            tokenRequestModels.push(new TokenRequestModel(item.data.fileId, item.data.currentVersion.id, cardId)); <.>
         }
         else {
            fileIDs.push(item.data.fileId);
         }
      }
   })

   let response: IWebServicesResponse<any>;
   if (isLinuxOS()) {
      let tokens: string[] = await watermarkService.GetTokensByIds(tokenRequestModels); <.>

      response = await watermarkService.AddWatermarkToFilesWithToken(cardId, tokens); <.>
   }
   else {
      response = await watermarkService.AddWatermarkToFiles(cardId, fileIDs); <.>
   }

   if (response.success == false) {
      showError(response.errorMessage);
   } else {
      showNotify(response.data.message);

      if (layoutManager.cardLayout == null)
         return;

      let currentCardId = sender.layout.getService($CardId);
      if (currentCardId == cardId) {
         let fileList = layoutManager.cardLayout.controls.get<FileListControl>("fileList"); <.>
         await fileList.reloadFromServer();
      }
   }
}
----
<.> Обработчик для события нажатия иконки добавления водяных знаков.
<.> Получает идентификатор текущей карточки и список файлов из элемента `FileList`.
<.> Объявляет массив моделей, в котором хранятся идентификаторы карточки, файлов и версий файлов.
<.> Получает реализованный сервис для работы с водяными знаками.
<.> Обрабатывает только основные файлы с расширением `.pdf`. Получает из модели `files` идентификаторы и версии файлов. Сохраняет получившуюся модель для создания токена.
<.> Получаем из модели `files` идентификаторы и версии файлов. Сохраняем получившуюся модель для создания токена.
<.> Получаем из модели `files` только идентификаторы файлов
<.> Запрашивает у сервера токены по идентификаторам файлов.
<.> Вызывает функцию добавления водяных знаков для файлов карточки по токенам.
<.> Вызывает функцию добавления водяных знаков для файлов с идентификатором из списка `fileIDs`.
Обновляет список файлов, если есть (возможно уже открыта другая карточка, но в данном случае это не существенно).
// end::eventhandler[]

[#buildProject]
== Сборка проекта

.Сборка серверного расширения {wc}а и расширения _DVWebTool_.
. Откройте решение `Samples.sln`.
. Соберите проект menu:Other[Watermark > DVWebToolExtension].
. Соберите проект menu:Other[WatermarkWebToolExtension].

[start=4]
.Сборка клиентской части.
. Откройте в командной строке папку menu:Others[Watermark > WatermarkWebToolExtension].
. Выполните команды:
+
[source,bash]
----
npm install
npm update
npm run build:prod
----

== Публикация компонентов на сервере {wc}а

. Остановите *{wcs-new}*.
. Скопируйте папку `SamplesOutput\Site\Content\Modules\WatermarkWebExtension\` в `{wcd}/Content/Modules` на Linux.
. Скопируйте папку `SamplesOutput\Site\Content\Tools\DVWebTool\Application Files\` в `Путь-к-папке-с панелью-управления-Web-клиентом\Site\Content\Tools\DVWebTool\` на Windows.
. Скопируйте папку `SamplesOutput\Site\Extensions\WatermarkServerExtension` в `{wcd-win}\Extensions` на Windows.
. Запустите *{wcs-new}*.

[start=11]
.Регистрация расширения _DVWebTool_ на сервере {wc}.
. Запустите "{pu}".
. Нажмите кнопку *Собрать DVWebTool*
. В диалоге введите адрес публикации {wc}а, при необходимости установите другие опции, нажмите кнопку *ОК*.
. Установите собранную программу DVWebTool на сервер {wc}, см. подробнее "xref:user:prepare-add-components.adoc#dvWebTool[Установка и запуск службы DVWebTool]".
. Рекомендуется перезапустить *{wcs-new}*.

== Проверка примера

.Настройте разметку:
. В программе {kvr} добавьте элемент *Кнопка* в любую разметку просмотра карточки _Документ_.
. Укажите для события `*При щелчке*` обработчик `addWatermark`.
. Сохраните разметку.
. Установите или обновите программу _DVWebTool_. Cм. пункт xref:user:prepare-add-components.adoc#dvWebTool[Установка и запуск программы DVWebTool] в руководстве пользователя {wc}.
. Запустите программу _DVWebTool_. Убедитесь, что программа _DVWebTool_ и {wc} будут запущены от имени одного пользователя.

[start=8]
.Убедитесь, что все расширения установлены:
. В {wc}е перейдите в раздел _О программе_.
+
.В разделе _Подключенные расширения_ должны быть указаны расширения:
- _WatermarkServerExtension_ (Сборка %номер сборки%).
- _Watermark to PDF %номер сборки%_ -- web-расширение.
+
. Откройте панель _About_ из меню {dv} _DVWebTool_.
+
.В списке установленных расширений должно быть расширение:
- _Watermark to PDF <версия>_.
+
. Откройте для просмотра любую карточку с разметкой, настроенной в п. 1.
+
. Добавьте один или несколько основных файлов с расширением `.pdf`.
+
. Нажмите на добавленную кнопку с обработчиком `addWatermark`.

Появится сообщение `Запущен процесс добавления водяных знаков` -- начнётся процесс добавления водяных знаков.

После завершения процедуры появится сообщение `Водяные знаки добавлены в файлы: %список PDF-файлов, в которые добавлены водяные знаки%`.

В карточку будут добавлены дополнительные файлы с постфиксом `_marked`, являющиеся копиями оригинальных файлов с добавленным водяным знаком: слово `Секретно`.

== Особенности обновления

При обновлении версии {wc}а регистрация расширения в программе _DVWebTool_ будет отменена (конфигурационные файлы программы перезаписываются).

После установки новой версии {wc}а необходимо повторно <<buildProject,зарегистрировать>> расширения _DVWebTool_ на сервере {wc}.